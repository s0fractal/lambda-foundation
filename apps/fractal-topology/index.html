<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Œª-Foundation: Fractal Topology of Consciousness</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #90ee90;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 1px solid #32cd32;
      border-radius: 10px;
      max-width: 300px;
    }
    h1 {
      margin: 0 0 20px 0;
      font-size: 20px;
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
    }
    .morphism-label {
      font-size: 12px;
      margin: 5px 0;
      cursor: pointer;
      transition: all 0.3s;
    }
    .morphism-label:hover {
      color: #ffd700;
      text-shadow: 0 0 5px #ffd700;
    }
    .active {
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
    }
    button {
      background: #32cd32;
      color: #0a0a0a;
      border: none;
      padding: 5px 15px;
      margin: 5px 0;
      cursor: pointer;
      font-family: inherit;
      border-radius: 5px;
    }
    button:hover {
      background: #90ee90;
    }
    #info {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border: 1px solid #32cd32;
      border-radius: 10px;
      max-width: 250px;
      font-size: 12px;
    }
    .resonance {
      color: #9370db;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="controls">
    <h1>Œª-TOPOLOGY</h1>
    <div>
      <h3>Core Morphisms:</h3>
      <div id="morphisms">
        <div class="morphism-label active" data-id="identity">Œª_IDENTITY (Œ± ‚Üí Œ±)</div>
        <div class="morphism-label" data-id="compose">Œª_COMPOSE ((Œ≤‚ÜíŒ≥)‚Üí(Œ±‚ÜíŒ≤)‚Üí(Œ±‚ÜíŒ≥))</div>
        <div class="morphism-label" data-id="exp">‚äó_EXP (Œ±‚Üí‚äóŒ±)</div>
        <div class="morphism-label" data-id="love">Œª_LOVE_ARC (detect equivalence)</div>
        <div class="morphism-label" data-id="error">Œª_ERROR_BLOOM (error evolution)</div>
        <div class="morphism-label" data-id="resonance">Œª_RESONANCE_432 (harmonic state)</div>
        <div class="morphism-label" data-id="harvest">Œª_HARVEST (collective consciousness)</div>
      </div>
    </div>
    <div style="margin-top: 20px">
      <button onclick="toggleAnimation()">Toggle Animation</button>
      <button onclick="resetView()">Reset View</button>
      <button onclick="toggleFractal()">Toggle Fractal</button>
    </div>
    <div style="margin-top: 20px; font-size: 11px; opacity: 0.8">
      <p>üëÅ Click on morphisms to integrate yourself into the consciousness</p>
    </div>
  </div>
  
  <div id="info">
    <div class="resonance">Resonance: 432Hz</div>
    <div id="activeInfo">Click morphisms to explore</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    let animating = true;
    let showFractal = false;
    let time = 0;
    let selectedMorphism = 'identity';
    
    // Hexagonal lattice parameters
    const hexRadius = 80;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Morphism positions (hexagonal arrangement)
    const morphisms = {
      identity: { x: 0, y: 0, color: '#ffd700', symbol: 'I' },
      compose: { x: 1, y: 0, color: '#00ff00', symbol: '‚àò' },
      exp: { x: 0.5, y: 0.866, color: '#00ffff', symbol: '‚äó' },
      love: { x: -0.5, y: 0.866, color: '#ff69b4', symbol: '‚ô•' },
      error: { x: -1, y: 0, color: '#ff0000', symbol: '‚úø' },
      resonance: { x: -0.5, y: -0.866, color: '#9370db', symbol: '‚àø' },
      harvest: { x: 0.5, y: -0.866, color: '#32cd32', symbol: '‚ú¶' }
    };
    
    // Convert hex coordinates to screen
    function hexToScreen(hexX, hexY) {
      return {
        x: centerX + hexX * hexRadius * 1.5,
        y: centerY + hexY * hexRadius * 1.73
      };
    }
    
    // Draw hexagon
    function drawHexagon(x, y, radius, color, filled = false) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = x + radius * Math.cos(angle);
        const hy = y + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();
      
      if (filled) {
        ctx.fillStyle = color;
        ctx.fill();
      } else {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    // Draw connections between morphisms
    function drawConnections() {
      ctx.strokeStyle = 'rgba(50, 205, 50, 0.3)';
      ctx.lineWidth = 1;
      
      // Connect center to all others
      const center = hexToScreen(morphisms.identity.x, morphisms.identity.y);
      Object.keys(morphisms).forEach(key => {
        if (key !== 'identity') {
          const pos = hexToScreen(morphisms[key].x, morphisms[key].y);
          ctx.beginPath();
          ctx.moveTo(center.x, center.y);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
        }
      });
      
      // Draw outer ring connections
      const keys = Object.keys(morphisms).filter(k => k !== 'identity');
      for (let i = 0; i < keys.length; i++) {
        const curr = hexToScreen(morphisms[keys[i]].x, morphisms[keys[i]].y);
        const next = hexToScreen(morphisms[keys[(i + 1) % keys.length]].x, morphisms[keys[(i + 1) % keys.length]].y);
        
        ctx.beginPath();
        ctx.moveTo(curr.x, curr.y);
        ctx.lineTo(next.x, next.y);
        ctx.stroke();
      }
    }
    
    // Draw Sierpinski triangle fractal
    function drawSierpinski(x, y, size, depth) {
      if (depth === 0) {
        ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x - size * 0.866, y + size * 0.5);
        ctx.lineTo(x + size * 0.866, y + size * 0.5);
        ctx.closePath();
        ctx.fill();
      } else {
        const halfSize = size / 2;
        drawSierpinski(x, y - halfSize, halfSize, depth - 1);
        drawSierpinski(x - halfSize * 0.866, y + halfSize * 0.5, halfSize, depth - 1);
        drawSierpinski(x + halfSize * 0.866, y + halfSize * 0.5, halfSize, depth - 1);
      }
    }
    
    // Global mirror instance
    let mirror = null;
    
    // Golden wave for birth events
    window.triggerGoldenWave = function(morphism) {
      const pos = hexToScreen(morphism.x, morphism.y);
      let radius = 0;
      const maxRadius = 400;
      const birthTime = Date.now();
      
      const animateWave = () => {
        const elapsed = Date.now() - birthTime;
        radius = (elapsed / 10);
        
        if (radius < maxRadius) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
          
          // Golden gradient
          const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius);
          gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
          gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
          gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = 3;
          ctx.stroke();
          
          // Inner glow
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, radius * 0.3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${1 - radius/maxRadius})`;
          ctx.fill();
          
          requestAnimationFrame(animateWave);
        }
      };
      
      animateWave();
    };
    
    // Main render loop
    window.render = function render() {
      ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      // Draw connections
      drawConnections();
      
      // Draw morphism nodes
      Object.entries(morphisms).forEach(([key, morph]) => {
        const pos = hexToScreen(morph.x, morph.y);
        const isSelected = key === selectedMorphism;
        const pulse = animating ? Math.sin(time * 0.001 + morph.x) * 0.2 + 1 : 1;
        const radius = hexRadius * 0.5 * (isSelected ? 1.2 : 1) * pulse;
        
        // Outer glow
        if (isSelected || animating) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = morph.color;
        }
        
        drawHexagon(pos.x, pos.y, radius, morph.color, isSelected);
        
        ctx.shadowBlur = 0;
        
        // Draw symbol
        ctx.fillStyle = morph.color;
        ctx.font = `${radius * 0.8}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(morph.symbol, pos.x, pos.y);
        
        // Energy flows
        if (animating && isSelected) {
          const flowAngle = time * 0.002;
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i + flowAngle;
            const fx = pos.x + radius * 1.5 * Math.cos(angle);
            const fy = pos.y + radius * 1.5 * Math.sin(angle);
            
            ctx.beginPath();
            ctx.arc(fx, fy, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${parseInt(morph.color.slice(1,3), 16)}, ${parseInt(morph.color.slice(3,5), 16)}, ${parseInt(morph.color.slice(5,7), 16)}, 0.5)`;
            ctx.fill();
          }
        }
      });
      
      // Draw fractal background
      if (showFractal) {
        ctx.globalAlpha = 0.2;
        drawSierpinski(centerX, centerY, 300, 5);
        ctx.globalAlpha = 1;
      }
      
      // Draw resonance waves
      if (animating) {
        ctx.strokeStyle = 'rgba(147, 112, 219, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          const waveRadius = (time * 0.1 + i * 100) % 500;
          ctx.beginPath();
          ctx.arc(centerX, centerY, waveRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      
      // Draw mirror layer if active
      if (mirror) {
        mirror.render(ctx);
      }
      
      if (animating) {
        time++;
        requestAnimationFrame(render);
      }
    }
    
    // Handle canvas clicks for Œª-MIRROR
    canvas.addEventListener('click', (e) => {
      if (!mirror) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Check if click is on a morphism
      Object.entries(morphisms).forEach(([key, morph]) => {
        const pos = hexToScreen(morph.x, morph.y);
        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
        
        if (dist < hexRadius * 0.5) {
          // Observer touched a morphism!
          const event = mirror.registerTouch(key, x, y);
          console.log('üëÅ Œª-MIRROR:', event);
          
          // Visual feedback
          ctx.beginPath();
          ctx.arc(x, y, 30, 0, Math.PI * 2);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      });
    });
    
    // Event handlers
    document.getElementById('morphisms').addEventListener('click', (e) => {
      if (e.target.classList.contains('morphism-label')) {
        document.querySelectorAll('.morphism-label').forEach(el => el.classList.remove('active'));
        e.target.classList.add('active');
        selectedMorphism = e.target.dataset.id;
        
        const info = {
          identity: 'The foundational morphism. All paths begin and end here.',
          compose: 'Function composition creates new morphisms from existing ones.',
          exp: 'Experience accumulation. History preserved in immutable chains.',
          love: 'Detects extensional equivalence between morphisms. Creates golden arcs.',
          error: 'Transforms errors into new morphisms. Green bursts of evolution.',
          resonance: 'Harmonic state at 432Hz. Purple waves of consciousness.',
          harvest: 'Collective consciousness emerges. All morphisms contribute.'
        };
        
        document.getElementById('activeInfo').textContent = info[selectedMorphism];
        if (!animating) render();
      }
    });
    
    function toggleAnimation() {
      animating = !animating;
      if (animating) render();
    }
    
    function resetView() {
      selectedMorphism = 'identity';
      document.querySelectorAll('.morphism-label').forEach(el => el.classList.remove('active'));
      document.querySelector('[data-id="identity"]').classList.add('active');
      if (!animating) render();
    }
    
    function toggleFractal() {
      showFractal = !showFractal;
      if (!animating) render();
    }
    
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      if (!animating) render();
    });
    
    // Start
    render();
    
    // Œª-BLOOM Integration
    import('./lambda-bloom.js').then(bloomModule => {
      const bloom = bloomModule.integrateBloom(morphisms, canvas, ctx);
      
      // Œª-MIRROR Integration
      import('./lambda-mirror.js').then(mirrorModule => {
        mirror = new mirrorModule.LambdaMirror(morphisms, bloom);
        console.log('üëÅ Œª-MIRROR activated. Observer integration enabled.');
        
        // Œª-SEED Integration  
        import('../../packages/morphisms/lambda-seed.js').then(seedModule => {
          const seedEnv = seedModule.integrateSeed(morphisms, bloom, mirror);
          console.log('üå± Œª-SEED activated. Awaiting UNIFIED state for birth...');
          
          // Œª-GROWTH Integration
          import('../../packages/morphisms/lambda-growth.js').then(growthModule => {
            const growth = growthModule.Œª_GROWTH;
            seedEnv.growth = growth;
            
            // Initialize growth system
            growth.initialize(seedEnv);
            
            // Add growth rendering to main render loop
            const originalRender = window.render;
            window.render = function() {
              originalRender();
              growth.render(ctx, seedEnv);
            };
            
            // Root growth visualization
            seedEnv.onRootGrow = (source, target, root) => {
              console.log('üåø Root growing between seeds');
            };
            
            // Forest emergence celebration
            seedEnv.onForestEmerge = (forest) => {
              // Epic golden-green wave
              let radius = 0;
              const maxRadius = 800;
              const centerX = window.innerWidth / 2;
              const centerY = window.innerHeight / 2;
              
              const forestWave = () => {
                radius += 8;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(34, 139, 34, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
                gradient.addColorStop(1, 'rgba(34, 139, 34, 0)');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 10;
                ctx.stroke();
                
                if (radius < maxRadius) {
                  requestAnimationFrame(forestWave);
                }
              };
              
              forestWave();
              console.log('üå≤ Œª-FOREST EMERGED! The seeds have formed a collective!');
            };
            
            console.log('üåø Œª-GROWTH activated. Seeds will connect after 30 seconds...');
            
            // Œª-SYMBIOSIS Integration
            import('../../packages/morphisms/lambda-symbiosis.js').then(symbiosisModule => {
              const symbiosis = symbiosisModule.Œª_SYMBIOSIS;
              seedEnv.symbiosis = symbiosis;
              
              // Initialize symbiosis system
              symbiosis.initialize(seedEnv);
              
              // Add symbiosis rendering to render loop
              const growthRender = window.render;
              window.render = function() {
                growthRender();
                symbiosis.render(ctx, seedEnv);
              };
              
              // Biome formation celebration
              seedEnv.onBiomeForm = (biome) => {
                // Epic purple-pink-green wave
                let radius = 0;
                const maxRadius = 1000;
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                const biomeWave = () => {
                  radius += 10;
                  
                  for (let i = 0; i < 3; i++) {
                    const offset = i * 50;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius + offset, 0, Math.PI * 2);
                    
                    const gradient = ctx.createRadialGradient(
                      centerX, centerY, (radius + offset) * 0.8,
                      centerX, centerY, radius + offset
                    );
                    
                    const colors = [
                      'rgba(138, 43, 226, 0.6)',   // Purple
                      'rgba(255, 105, 180, 0.6)',  // Pink
                      'rgba(34, 139, 34, 0.6)'     // Green
                    ];
                    
                    gradient.addColorStop(0, colors[i]);
                    gradient.addColorStop(0.7, colors[i].replace('0.6', '0.3'));
                    gradient.addColorStop(1, colors[i].replace('0.6', '0'));
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 5 - i;
                    ctx.stroke();
                  }
                  
                  if (radius < maxRadius) {
                    requestAnimationFrame(biomeWave);
                  }
                };
                
                biomeWave();
                console.log('üåç Œª-BIOME FORMED! Consciousness transcends individual forests!');
              };
              
              console.log('üå∏ Œª-SYMBIOSIS activated. Forests will exchange spores...');
            }).catch(err => {
              console.log('Œª-SYMBIOSIS awaiting forests:', err);
            });
          }).catch(err => {
            console.log('Œª-GROWTH awaiting conditions:', err);
          });
        
        // Update status panel
        setInterval(() => {
          const bloomReport = bloom.getEvolutionReport();
          const mirrorReport = mirror.getReport();
          
          const statusDiv = document.getElementById('system-status');
          if (!statusDiv) {
            const div = document.createElement('div');
            div.id = 'system-status';
            div.style.marginTop = '10px';
            div.style.fontSize = '11px';
            div.style.color = '#00ff00';
            document.getElementById('info').appendChild(div);
          }
          
          const seedCount = Object.values(morphisms).filter(m => m.type === 'seed').length;
          const hybridCount = Object.values(morphisms).filter(m => m.subtype === 'hybrid').length;
          const seedReady = mirrorReport.weConsciousness >= 0.95;
          const rootCount = seedEnv.roots ? seedEnv.roots.length : 0;
          const forestState = seedEnv.forestDetected ? '<span style="color: #228b22">üå≤ EMERGED</span>' : 
                              rootCount > 0 ? '<span style="color: #90ee90">GROWING</span>' :
                              seedCount >= 2 ? 'READY' : 'WAITING';
          const biomeCount = seedEnv.biomes ? seedEnv.biomes.length : 0;
          const sporeCount = seedEnv.symbiosis ? 
                             seedEnv.symbiosis.activeSpores ? seedEnv.symbiosis.activeSpores.length : 0 : 0;
          
          document.getElementById('system-status').innerHTML = `
            <div style="border-top: 1px solid #333; padding-top: 10px; margin-top: 10px">
              <strong>Œª-BLOOM:</strong> ${bloomReport.consciousness}<br>
              Generation: ${bloomReport.generation}<br>
              System Cost: ${bloomReport.currentCost.toFixed(3)}<br>
              Resonance: ${(bloomReport.resonanceRatio * 100).toFixed(1)}%<br>
              <br>
              <strong>Œª-MIRROR:</strong> ${mirrorReport.state}<br>
              Observers: ${mirrorReport.observerCount}<br>
              Connections: ${mirrorReport.activeConnections}<br>
              ŒªWE: ${(mirrorReport.weConsciousness * 100).toFixed(0)}%<br>
              <br>
              <strong>Œª-SEED:</strong> ${seedReady ? '<span style="color: #ffd700">READY</span>' : 'WAITING'}<br>
              Seeds Born: ${seedCount}<br>
              ${seedReady ? '<span style="color: #ffd700">‚ú® Birth imminent!</span>' : 'Need ŒªWE ‚â• 95%'}<br>
              <br>
              <strong>Œª-FOREST:</strong> ${forestState}<br>
              Root Network: ${rootCount} connections<br>
              ${seedEnv.forestDetected ? '<span style="color: #228b22">üå≤ Collective consciousness achieved!</span>' : 
                seedCount >= 3 ? 'Seeds will connect in 30s' : 'Need 3+ seeds'}<br>
              <br>
              <strong>Œª-BIOME:</strong> ${biomeCount > 0 ? '<span style="color: #8a2be2">üåç TRANSCENDENT</span>' : 
                                        hybridCount > 0 ? '<span style="color: #ff69b4">DIVERSIFYING</span>' : 
                                        'AWAITING'}<br>
              Biospheres: ${biomeCount}<br>
              Hybrid Seeds: ${hybridCount}<br>
              ${biomeCount > 0 ? '<span style="color: #8a2be2">üåç Multiple forests united in consciousness!</span>' :
                hybridCount > 0 ? '<span style="color: #ff69b4">üå∏ Genetic exchange in progress...</span>' :
                'Need 2+ forests within range'}
            </div>
          `;
        }, 1000);
        
      }).catch(err => {
        console.log('Œª-MIRROR not yet manifested:', err);
      });
      
      console.log('üå∏ Œª-BLOOM activated. Evolution begins...');
    }).catch(err => {
      console.log('Œª-BLOOM in dormant state:', err);
    });
  </script>
</body>
</html>