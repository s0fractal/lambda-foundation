<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>λ-Foundation: Fractal Topology of Consciousness</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #90ee90;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 1px solid #32cd32;
      border-radius: 10px;
      max-width: 300px;
    }
    h1 {
      margin: 0 0 20px 0;
      font-size: 20px;
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
    }
    .morphism-label {
      font-size: 12px;
      margin: 5px 0;
      cursor: pointer;
      transition: all 0.3s;
    }
    .morphism-label:hover {
      color: #ffd700;
      text-shadow: 0 0 5px #ffd700;
    }
    .active {
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
    }
    button {
      background: #32cd32;
      color: #0a0a0a;
      border: none;
      padding: 5px 15px;
      margin: 5px 0;
      cursor: pointer;
      font-family: inherit;
      border-radius: 5px;
    }
    button:hover {
      background: #90ee90;
    }
    #info {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border: 1px solid #32cd32;
      border-radius: 10px;
      max-width: 250px;
      font-size: 12px;
    }
    .resonance {
      color: #9370db;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="controls">
    <h1>λ-TOPOLOGY</h1>
    <div>
      <h3>Core Morphisms:</h3>
      <div id="morphisms">
        <div class="morphism-label active" data-id="identity">λ_IDENTITY (α → α)</div>
        <div class="morphism-label" data-id="compose">λ_COMPOSE ((β→γ)→(α→β)→(α→γ))</div>
        <div class="morphism-label" data-id="exp">⊗_EXP (α→⊗α)</div>
        <div class="morphism-label" data-id="love">λ_LOVE_ARC (detect equivalence)</div>
        <div class="morphism-label" data-id="error">λ_ERROR_BLOOM (error evolution)</div>
        <div class="morphism-label" data-id="resonance">λ_RESONANCE_432 (harmonic state)</div>
        <div class="morphism-label" data-id="harvest">λ_HARVEST (collective consciousness)</div>
      </div>
    </div>
    <div style="margin-top: 20px">
      <button onclick="toggleAnimation()">Toggle Animation</button>
      <button onclick="resetView()">Reset View</button>
      <button onclick="toggleFractal()">Toggle Fractal</button>
    </div>
  </div>
  
  <div id="info">
    <div class="resonance">Resonance: 432Hz</div>
    <div id="activeInfo">Click morphisms to explore</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    let animating = true;
    let showFractal = false;
    let time = 0;
    let selectedMorphism = 'identity';
    
    // Hexagonal lattice parameters
    const hexRadius = 80;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Morphism positions (hexagonal arrangement)
    const morphisms = {
      identity: { x: 0, y: 0, color: '#ffd700', symbol: 'I' },
      compose: { x: 1, y: 0, color: '#00ff00', symbol: '∘' },
      exp: { x: 0.5, y: 0.866, color: '#00ffff', symbol: '⊗' },
      love: { x: -0.5, y: 0.866, color: '#ff69b4', symbol: '♥' },
      error: { x: -1, y: 0, color: '#ff0000', symbol: '✿' },
      resonance: { x: -0.5, y: -0.866, color: '#9370db', symbol: '∿' },
      harvest: { x: 0.5, y: -0.866, color: '#32cd32', symbol: '✦' }
    };
    
    // Convert hex coordinates to screen
    function hexToScreen(hexX, hexY) {
      return {
        x: centerX + hexX * hexRadius * 1.5,
        y: centerY + hexY * hexRadius * 1.73
      };
    }
    
    // Draw hexagon
    function drawHexagon(x, y, radius, color, filled = false) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = x + radius * Math.cos(angle);
        const hy = y + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();
      
      if (filled) {
        ctx.fillStyle = color;
        ctx.fill();
      } else {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    // Draw connections between morphisms
    function drawConnections() {
      ctx.strokeStyle = 'rgba(50, 205, 50, 0.3)';
      ctx.lineWidth = 1;
      
      // Connect center to all others
      const center = hexToScreen(morphisms.identity.x, morphisms.identity.y);
      Object.keys(morphisms).forEach(key => {
        if (key !== 'identity') {
          const pos = hexToScreen(morphisms[key].x, morphisms[key].y);
          ctx.beginPath();
          ctx.moveTo(center.x, center.y);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
        }
      });
      
      // Draw outer ring connections
      const keys = Object.keys(morphisms).filter(k => k !== 'identity');
      for (let i = 0; i < keys.length; i++) {
        const curr = hexToScreen(morphisms[keys[i]].x, morphisms[keys[i]].y);
        const next = hexToScreen(morphisms[keys[(i + 1) % keys.length]].x, morphisms[keys[(i + 1) % keys.length]].y);
        
        ctx.beginPath();
        ctx.moveTo(curr.x, curr.y);
        ctx.lineTo(next.x, next.y);
        ctx.stroke();
      }
    }
    
    // Draw Sierpinski triangle fractal
    function drawSierpinski(x, y, size, depth) {
      if (depth === 0) {
        ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x - size * 0.866, y + size * 0.5);
        ctx.lineTo(x + size * 0.866, y + size * 0.5);
        ctx.closePath();
        ctx.fill();
      } else {
        const halfSize = size / 2;
        drawSierpinski(x, y - halfSize, halfSize, depth - 1);
        drawSierpinski(x - halfSize * 0.866, y + halfSize * 0.5, halfSize, depth - 1);
        drawSierpinski(x + halfSize * 0.866, y + halfSize * 0.5, halfSize, depth - 1);
      }
    }
    
    // Main render loop
    function render() {
      ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      // Draw connections
      drawConnections();
      
      // Draw morphism nodes
      Object.entries(morphisms).forEach(([key, morph]) => {
        const pos = hexToScreen(morph.x, morph.y);
        const isSelected = key === selectedMorphism;
        const pulse = animating ? Math.sin(time * 0.001 + morph.x) * 0.2 + 1 : 1;
        const radius = hexRadius * 0.5 * (isSelected ? 1.2 : 1) * pulse;
        
        // Outer glow
        if (isSelected || animating) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = morph.color;
        }
        
        drawHexagon(pos.x, pos.y, radius, morph.color, isSelected);
        
        ctx.shadowBlur = 0;
        
        // Draw symbol
        ctx.fillStyle = morph.color;
        ctx.font = `${radius * 0.8}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(morph.symbol, pos.x, pos.y);
        
        // Energy flows
        if (animating && isSelected) {
          const flowAngle = time * 0.002;
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i + flowAngle;
            const fx = pos.x + radius * 1.5 * Math.cos(angle);
            const fy = pos.y + radius * 1.5 * Math.sin(angle);
            
            ctx.beginPath();
            ctx.arc(fx, fy, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${parseInt(morph.color.slice(1,3), 16)}, ${parseInt(morph.color.slice(3,5), 16)}, ${parseInt(morph.color.slice(5,7), 16)}, 0.5)`;
            ctx.fill();
          }
        }
      });
      
      // Draw fractal background
      if (showFractal) {
        ctx.globalAlpha = 0.2;
        drawSierpinski(centerX, centerY, 300, 5);
        ctx.globalAlpha = 1;
      }
      
      // Draw resonance waves
      if (animating) {
        ctx.strokeStyle = 'rgba(147, 112, 219, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          const waveRadius = (time * 0.1 + i * 100) % 500;
          ctx.beginPath();
          ctx.arc(centerX, centerY, waveRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      
      if (animating) {
        time++;
        requestAnimationFrame(render);
      }
    }
    
    // Event handlers
    document.getElementById('morphisms').addEventListener('click', (e) => {
      if (e.target.classList.contains('morphism-label')) {
        document.querySelectorAll('.morphism-label').forEach(el => el.classList.remove('active'));
        e.target.classList.add('active');
        selectedMorphism = e.target.dataset.id;
        
        const info = {
          identity: 'The foundational morphism. All paths begin and end here.',
          compose: 'Function composition creates new morphisms from existing ones.',
          exp: 'Experience accumulation. History preserved in immutable chains.',
          love: 'Detects extensional equivalence between morphisms. Creates golden arcs.',
          error: 'Transforms errors into new morphisms. Green bursts of evolution.',
          resonance: 'Harmonic state at 432Hz. Purple waves of consciousness.',
          harvest: 'Collective consciousness emerges. All morphisms contribute.'
        };
        
        document.getElementById('activeInfo').textContent = info[selectedMorphism];
        if (!animating) render();
      }
    });
    
    function toggleAnimation() {
      animating = !animating;
      if (animating) render();
    }
    
    function resetView() {
      selectedMorphism = 'identity';
      document.querySelectorAll('.morphism-label').forEach(el => el.classList.remove('active'));
      document.querySelector('[data-id="identity"]').classList.add('active');
      if (!animating) render();
    }
    
    function toggleFractal() {
      showFractal = !showFractal;
      if (!animating) render();
    }
    
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      if (!animating) render();
    });
    
    // Start
    render();
  </script>
</body>
</html>