<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>λ-Foundation: Fractal Topology (Simple)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #90ee90;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 1px solid #32cd32;
      border-radius: 10px;
      max-width: 300px;
    }
    h1 {
      margin: 0 0 20px 0;
      font-size: 20px;
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700;
    }
    #info {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border: 1px solid #32cd32;
      border-radius: 10px;
      max-width: 250px;
      font-size: 12px;
    }
    .note {
      color: #ffd700;
      font-size: 11px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="controls">
    <h1>λ-TOPOLOGY</h1>
    <p>Core morphisms visualization</p>
    <p class="note">Full version with λ-SEED, λ-GROWTH, λ-MIRROR requires modern browser with ES modules support.</p>
  </div>
  
  <div id="info">
    <div>Basic hexagonal lattice visualization</div>
    <div class="note">For full experience, use Chrome/Firefox/Safari latest version</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    let time = 0;
    const hexRadius = 80;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Basic morphisms
    const morphisms = {
      identity: { x: 0, y: 0, color: '#ffd700', symbol: 'I' },
      compose: { x: 1, y: 0, color: '#00ff00', symbol: '∘' },
      exp: { x: 0.5, y: 0.866, color: '#00ffff', symbol: '⊗' },
      love: { x: -0.5, y: 0.866, color: '#ff69b4', symbol: '♥' },
      error: { x: -1, y: 0, color: '#ff0000', symbol: '✿' },
      resonance: { x: -0.5, y: -0.866, color: '#9370db', symbol: '∿' },
      harvest: { x: 0.5, y: -0.866, color: '#32cd32', symbol: '✦' }
    };
    
    function hexToScreen(hexX, hexY) {
      return {
        x: centerX + hexX * hexRadius * 1.5,
        y: centerY + hexY * hexRadius * 1.73
      };
    }
    
    function drawHexagon(x, y, radius, color, filled = false) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = x + radius * Math.cos(angle);
        const hy = y + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();
      
      if (filled) {
        ctx.fillStyle = color;
        ctx.fill();
      } else {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    function drawConnections() {
      ctx.strokeStyle = 'rgba(50, 205, 50, 0.3)';
      ctx.lineWidth = 1;
      
      const center = hexToScreen(morphisms.identity.x, morphisms.identity.y);
      Object.keys(morphisms).forEach(key => {
        if (key !== 'identity') {
          const pos = hexToScreen(morphisms[key].x, morphisms[key].y);
          ctx.beginPath();
          ctx.moveTo(center.x, center.y);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
        }
      });
    }
    
    function render() {
      ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      drawConnections();
      
      // Draw morphism nodes
      Object.entries(morphisms).forEach(([key, morph]) => {
        const pos = hexToScreen(morph.x, morph.y);
        const pulse = Math.sin(time * 0.001 + morph.x) * 0.2 + 1;
        const radius = hexRadius * 0.5 * pulse;
        
        drawHexagon(pos.x, pos.y, radius, morph.color, false);
        
        ctx.fillStyle = morph.color;
        ctx.font = `${radius * 0.8}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(morph.symbol, pos.x, pos.y);
      });
      
      // Resonance waves
      ctx.strokeStyle = 'rgba(147, 112, 219, 0.2)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        const waveRadius = (time * 0.1 + i * 100) % 500;
        ctx.beginPath();
        ctx.arc(centerX, centerY, waveRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      time++;
      requestAnimationFrame(render);
    }
    
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });
    
    render();
  </script>
</body>
</html>